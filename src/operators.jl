# Inline helper functions.
@inline incmod1(a, n) = a == n ? one(a) : a + 1
@inline decmod1(a, n) = a == 1 ? n : a - 1

# Functions to calculate the x, y, and z-derivatives on an Arakawa C-grid at
# every grid point:
#     Œ¥À£(f) = (f)·¥± - (f)·µÇ,   Œ¥ ∏(f) = (f)·¥∫ - (f)À¢,   Œ¥·∂ª(f) = (f)·µÄ - (f)·¥Æ
# where the E, W, N, and S superscripts indicate that the value of f is
# evaluated on the eastern, western, northern, and southern walls of the cell,
# respectively. Similarly, the T and B superscripts indicate the top and bottom
# walls of the cell.

#=
Some benchmarking with Nx, Ny, Nz = 200, 200, 200.

using BenchmarkTools

A = reshape(collect(0:Nx*Ny*Nz-1), (Nx, Ny, Nz));
B = zeros((Nx, Ny, Nz));

@btime Œ¥À£($A);
  54.556 ms (22 allocations: 122.07 MiB)

@btime Œ¥À£b!($A, $B)  # With bounds checking.
  19.870 ms (0 allocations: 0 bytes)

@btime Œ¥À£!($A, $B)  # With @inbounds. Looping in fast k, j, i order.
  16.862 ms (0 allocations: 0 bytes)

@btime Œ¥À£!!($A, $B)  # With @inbounds. Looping in slow i, j, k order.
  92.987 ms (0 allocations: 0 bytes)
=#

# Œ¥À£c2f, Œ¥ ∏c2f, and Œ¥·∂ªc2f calculate a difference in the x, y, and
# z-directions for a field defined at the cell centers
# and projects it onto the cell faces.

# Input: Field defined at the u-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function Œ¥À£c2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[i, j, k] - f[decmod1(i,Nx), j, k]
    end
    Œ¥f
end

# Input: Field defined at the v-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function Œ¥ ∏c2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[i, j, k] - f[i, decmod1(j,Ny), k]
    end
    Œ¥f
end

# Input: Field defined at the w-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function Œ¥·∂ªc2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 2:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[i, j, k] - f[i, j, decmod1(k,Nz)]
    end
    @. Œ¥f[:, :, 1] = 0
    Œ¥f
end

# Œ¥À£f2c, Œ¥ ∏f2c, and Œ¥·∂ªf2c calculate a difference in the x, y, and
# z-directions for a field defined at the cell faces
# and projects it onto the cell centers.

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the u-faces, which has size (Nx, Ny, Nz).
function Œ¥À£f2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[incmod1(i, Nx), j, k] - f[i, j, k]
    end
    Œ¥f
end

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the v-faces, which has size (Nx, Ny, Nz).
function Œ¥ ∏f2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[i, incmod1(j, Ny), k] - f[i, j, k]
    end
    Œ¥f
end

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the v-faces, which has size (Nx, Ny, Nz).
function Œ¥·∂ªf2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:(Nz-1), j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  f[i, j, incmod1(k, Nz)] - f[i, j, k]
    end
    @. Œ¥f[:, :, end] = 0
    Œ¥f
end

# function Œ¥À£!(g::Grid, f, Œ¥À£f)
#     for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx
#       @inbounds Œ¥À£f[i, j, k] = f[i, j, k] - f[decmod1(i, Nx), j, k]
#     end
# end
#
# function Œ¥ ∏!(g::Grid, f, Œ¥ ∏f)
#     for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx
#       @inbounds Œ¥À£f[i, j, k] = f[i, j, k] - f[decmod1(i, Nx), j, k]
#     end
# end

# Functions to calculate the value of a quantity on a face as the average of
# the quantity in the two cells to which the face is common:
#     ÃÖqÀ£ = (q·¥± + q·µÇ) / 2,   ÃÖq ∏ = (q·¥∫ + qÀ¢) / 2,   ÃÖq·∂ª = (q·µÄ + q·¥Æ) / 2
# where the superscripts are as defined for the derivative operators.

# In case avg‚Å± is called on a scalar s, e.g. AÀ£ on a RegularCartesianGrid, just
# return the scalar.
avgÀ£c2f(s::Number) = s
avg ∏c2f(s::Number) = s
avg·∂ªc2f(s::Number) = s
avgÀ£f2c(s::Number) = s
avg ∏f2c(s::Number) = s
avg·∂ªf2c(s::Number) = s

# Input: Field defined at the u-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function avgÀ£c2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[i, j, k] + f[decmod1(i,Nx), j, k]) / 2
    end
    Œ¥f
end

# Input: Field defined at the v-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function avg ∏c2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[i, j, k] + f[i, decmod1(j,Ny), k]) / 2
    end
    Œ¥f
end

# Input: Field defined at the w-faces, which has size (Nx, Ny, Nz).
# Output: Field defined at the cell centers, which has size (Nx, Ny, Nz).
function avg·∂ªc2f(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 2:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[i, j, k] + f[i, j, decmod1(k,Nz)]) / 2
    end
    @. Œ¥f[:, :, 1] = 0
    Œ¥f
end

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the u-faces, which has size (Nx, Ny, Nz).
function avgÀ£f2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[incmod1(i, Nx), j, k] + f[i, j, k]) / 2
    end
    Œ¥f
end

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the v-faces, which has size (Nx, Ny, Nz).
function avg ∏f2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:Nz, j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[i, incmod1(j, Ny), k] + f[i, j, k]) / 2
    end
    Œ¥f
end

# Input: Field defined at the cell centers, which has size (Nx, Ny, Nz).
# Output: Field defined at the w-faces, which has size (Nx, Ny, Nz).
function avg·∂ªf2c(f)
    Nx, Ny, Nz = size(f)
    Œ¥f = zeros(Nx, Ny, Nz)
    for k in 1:(Nz-1), j in 1:Ny, i in 1:Nx
        Œ¥f[i, j, k] =  (f[i, j, incmod1(k, Nz)] + f[i, j, k]) / 2
    end
    @. Œ¥f[:, :, end] = 0
    Œ¥f
end

# Input: fÀ£ is on a u-face grid with size (Nx, Ny, Nz).
#        f ∏ is on a v-face grid with size (Nx, Ny, Nz).
#        f·∂ª is on a w-face grid with size (Nx, Ny, Nz).
# Output: ‚àá¬∑Ã≤f is on a zone/cell center grid with size (Nx, Ny, Nz).
function div_f2c(fÀ£, f ∏, f·∂ª)
    V·µò = V
    (1/V·µò) * ( Œ¥À£f2c(AÀ£ .* fÀ£) + Œ¥ ∏f2c(A ∏ .* f ∏) + Œ¥·∂ªf2c(A·∂ª .* f·∂ª) )
end

# Input: fÀ£ is on a cell center grid with size (Nx, Ny, Nz).
#        f ∏ is on a cell center grid with size (Nx, Ny, Nz).
#        f·∂ª is on a cell center grid with size (Nx, Ny, Nz).
# Output: ‚àá¬∑Ã≤f is on a face grid with size (Nx, Ny, Nz). The exact face depends
#         on the quantitify fÃÉ = (fx, fy, fz) being differentiated.
function div_c2f(fÀ£, f ∏, f·∂ª)
    V·µò = V
    (1/V·µò) * ( Œ¥À£c2f(AÀ£ .* fÀ£) + Œ¥ ∏c2f(A ∏ .* f ∏) + Œ¥·∂ªc2f(A·∂ª .* f·∂ª) )
end

# Calculate the divergence of a flux of Q over a zone with velocity field
# uÃÉ = (u,v,w): ‚àá ‚ãÖ (uÃÉQ).
# Input: u is on a u-face grid with size (Nx, Ny, Nz).
#        v is on a v-face grid with size (Nx, Ny, Nz).
#        w is on a w-face grid with size (Nx, Ny, Nz).
#        Q is on a zone/cell center grid with size (Nx, Ny, Nz).
# Output: ‚àá¬∑(uÃ≤Q) is on zone/cell center grid with size (Nx, Ny, Nz).
function div_flux_f2c(u, v, w, Q)
    V·µò = V
    flux_x = AÀ£ .* u .* avgÀ£c2f(Q)
    flux_y = A ∏ .* v .* avg ∏c2f(Q)
    flux_z = A·∂ª .* w .* avg·∂ªc2f(Q)

    # Imposing zero vertical flux through the top and bottom layers.
    @. flux_z[:, :, 1] = 0
    @. flux_z[:, :, end] = 0

    (1/V·µò) .* (Œ¥À£f2c(flux_x) .+ Œ¥ ∏f2c(flux_y) .+ Œ¥·∂ªf2c(flux_z))
end

# Calculate the nonlinear advection (inertiaL acceleration or convective
# acceleration in other fields) terms ‚àá ‚ãÖ (Vu), ‚àá ‚ãÖ (Vv), and ‚àá ‚ãÖ (Vw) where
# V = (u,v,w). Each component gets its own function for now until we can figure
# out how to combine them all into one function.
function uÃÉ‚àáu(u, v, w)
  V·µò = V
  (1/V·µò) .* (Œ¥À£c2f(avgÀ£f2c(AÀ£.*u) .* avgÀ£f2c(u)) + Œ¥ ∏c2f(avgÀ£f2c(A ∏.*v) .* avg ∏f2c(u)) + Œ¥·∂ªc2f(avgÀ£f2c(A·∂ª.*w) .* avg·∂ªf2c(u)))
end

function uÃÉ‚àáv(u, v, w)
  V·µò = V
  (1/V·µò) .* (Œ¥À£c2f(avg ∏f2c(AÀ£.*u) .* avgÀ£f2c(v)) + Œ¥ ∏c2f(avg ∏f2c(A ∏.*v) .* avg ∏f2c(v)) + Œ¥·∂ªc2f(avg ∏f2c(A·∂ª.*w) .* avg·∂ªf2c(v)))
end

function uÃÉ‚àáw(u, v, w)
  V·µò = V
  uwÃÇ_transport = avg·∂ªf2c(AÀ£.*u) .* avgÀ£f2c(w)
  vwÃÇ_transport = avg·∂ªf2c(A ∏.*v) .* avg ∏f2c(w)
  wwÃÇ_transport = avg·∂ªf2c(A·∂ª.*w) .* avg·∂ªf2c(w)

  wwÃÇ_transport[:, :, 1]  .= 0
  wwÃÇ_transport[:, :, end] .= 0

  (1/V·µò) .* (Œ¥À£c2f(uwÃÇ_transport) .+ Œ¥ ∏c2f(vwÃÇ_transport) .+ Œ¥·∂ªc2f(wwÃÇ_transport))
end

Œ∫ ∞ = 4e-2  # Horizontal Laplacian heat diffusion [m¬≤/s]. diffKhT in MITgcm.
Œ∫·µõ = 4e-2  # Vertical Laplacian heat diffusion [m¬≤/s]. diffKzT in MITgcm.

# Laplacian diffusion for zone quantities: ‚àá ¬∑ (Œ∫‚àáQ)
# Input: Q is on a cell centered grid with size (Nx, Ny, Nz).
# Output: ‚àá¬∑(Œ∫‚àáQ) is on a cell centered grid with size (Nx, Ny, Nz).
function Œ∫‚àá¬≤(Q)
  V·µò = V
  Œ∫‚àáQ_x = Œ∫ ∞ .* AÀ£ .* Œ¥À£c2f(Q)
  Œ∫‚àáQ_y = Œ∫ ∞ .* A ∏ .* Œ¥ ∏c2f(Q)
  Œ∫‚àáQ_z = Œ∫·µõ .* A·∂ª .* Œ¥·∂ªc2f(Q)
  (1/V·µò) .* div_f2c(Œ∫‚àáQ_x, Œ∫‚àáQ_y, Œ∫‚àáQ_z)
end

ùúà ∞ = 4e-2  # Horizontal eddy viscosity [Pa¬∑s]. viscAh in MITgcm.
ùúà·µõ = 4e-2  # Vertical eddy viscosity [Pa¬∑s]. viscAz in MITgcm.

# Laplacian diffusion for horizontal face quantities: ‚àá ¬∑ (ŒΩ‚àáu)
function ùúà ∞‚àá¬≤(u)
  V·µò = V
  ùúà‚àáu_x = ùúà ∞ .* avgÀ£f2c(AÀ£) .* Œ¥À£f2c(u)
  ùúà‚àáu_y = ùúà ∞ .* avg ∏f2c(A ∏) .* Œ¥ ∏f2c(u)
  ùúà‚àáu_z = ùúà·µõ .* avg·∂ªf2c(A·∂ª) .* Œ¥·∂ªf2c(u)
  (1/V·µò) .* div_c2f(ùúà‚àáu_x, ùúà‚àáu_y, ùúà‚àáu_z)
end

# Laplacian diffusion for vertical face quantities: ‚àá ¬∑ (ŒΩ‚àáw)
function ùúà·µõ‚àá¬≤(u)
  V·µò = V
  ùúà‚àáu_x = ùúà ∞ .* avgÀ£f2c(AÀ£) .* Œ¥À£f2c(u)
  ùúà‚àáu_y = ùúà ∞ .* avg ∏f2c(A ∏) .* Œ¥ ∏f2c(u)
  ùúà‚àáu_z = ùúà·µõ .* avg·∂ªf2c(A·∂ª) .* Œ¥·∂ªf2c(u)

  # Imposing free slip viscous boundary conditions at the bottom layer.
  @. ùúà‚àáu_z[:, :,  1] = 0
  @. ùúà‚àáu_z[:, :, end] = 0

  (1/V·µò) .* div_c2f(ùúà‚àáu_x, ùúà‚àáu_y, ùúà‚àáu_z)
end

horizontal_laplacian(f) = circshift(f, (1, 0, 0)) + circshift(f, (-1, 0, 0)) + circshift(f, (0, 1, 0)) + circshift(f, (0, -1, 0)) - 4 .* f

laplacian(f) = circshift(f, (1, 0, 0)) + circshift(f, (-1, 0, 0)) + circshift(f, (0, 1, 0)) + circshift(f, (0, -1, 0)) + circshift(f, (0, 0, 1)) + circshift(f, (0, -1, 0)) - 6 .* f

function laplacian3d_ppn(f)
    Nx, Ny, Nz = size(f)
    ‚àá¬≤f = zeros(Nx, Ny, Nz)
    for k in 2:(Nz-1), j in 1:Ny, i in 1:Nx
       ‚àá¬≤f[i, j, k] = f[incmod1(i, Nx), j, k] + f[decmod1(i, Nx), j, k] + f[i, incmod1(j, Ny), k] + f[i, decmod1(j, Ny), k] + f[i, j, k+1] + f[i, j, k-1] - 6*f[i, j, k]
    end
    for j in 1:Ny, i in 1:Nx
        ‚àá¬≤f[i, j,   1] = -(f[i, j,     1] - f[i, j,   2]) + f[incmod1(i, Nx), j,   1] + f[decmod1(i, Nx), j,   1] + f[i, incmod1(j, Ny),   1] + f[i, decmod1(j, Ny),   1] - 4*f[i, j,   1]
        ‚àá¬≤f[i, j, end] =  (f[i, j, end-1] - f[i, j, end]) + f[incmod1(i, Nx), j, end] + f[decmod1(i, Nx), j, end] + f[i, incmod1(j, Ny), end] + f[i, decmod1(j, Ny), end] - 4*f[i, j, end]
    end
    ‚àá¬≤f
end
