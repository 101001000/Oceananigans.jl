# # Horizontal convection example
#
# In this example, we initialize a random velocity field and observe its viscous,
# turbulent decay in a two-dimensional domain. This example demonstrates:
#
#   * How to use a tuple of turbulence closures
#   * How to use hyperdiffusivity
#   * How to implement background velocity and tracer distributions
#   * How to use `ComputedField`s for output
#
# ## Install dependencies
#
# First let's make sure we have all required packages installed.

# ```julia
# using Pkg
# pkg"add Oceananigans, JLD2, Plots"
# ```

# ## The Eady problem
#
# The "Eady problem" simulates the baroclinic instability problem proposed by Eric Eady in
# the classic paper
# ["Long waves and cyclone waves," Tellus (1949)](https://doi.org/10.3402/tellusa.v1i3.8507).
# The Eady problem is a simple, canonical model for the generation of mid-latitude
# atmospheric storms and the ocean eddies that permeate the world sea.
#
# In the Eady problem, baroclinic motion and turublence is generated by the interaction
# between turbulent motions and a stationary, geostrophically-balanced basic state that
# is unstable to baroclinic instability. In this example, the baroclinic generation of
# turbulence due to extraction of energy from the geostrophic basic state
# is balanced by a bottom boundary condition that extracts momentum from turbulent motions
# and serves as a crude model for the drag associated with an unresolved and small-scale
# turbulent bottom boundary layer.
#
# ### The geostrophic basic state
#
# The geostrophic basic state in the Eady problem is represented by the streamfunction,
#
# ```math
# ψ(y, z) = - α y (z + L_z) \, ,
# ```
#
# where ``α`` is the geostrophic shear and ``L_z`` is the depth of the domain.
# The background buoyancy includes both the geostrophic flow component,
# ``f ∂_z ψ``, where ``f`` is the Coriolis parameter, and a background stable stratification
# component, ``N^2 z``, where ``N`` is the buoyancy frequency:
#
# ```math
# B(y, z) = f ∂_z ψ + N^2 z = - α f y + N^2 z \, .
# ```
#
# The background velocity field is related to the geostrophic streamfunction via
# ``U = - ∂_y ψ`` such that
#
# ```math
# U(z) = α (z + L_z) \, .
# ```
#
# ### Boundary conditions
#
# All fields are periodic in the horizontal directions.
# We use "insulating", or zero-flux boundary conditions on the buoyancy perturbation
# at the top and bottom. We thus implicitly assume that the background vertical density
# gradient, ``N^2 z``, is maintained by a process external to our simulation.
# We use free-slip, or zero-flux boundary conditions on ``u`` and ``v`` at the surface
# where ``z=0``. At the bottom, we impose a momentum flux that extracts momentum and
# energy from the flow.
#
# #### Bottom boundary condition: quadratic bottom drag
#
# We model the effects of a turbulent bottom boundary layer on the eddy momentum budget
# with quadratic bottom drag. A quadratic cottom drag is introduced by imposing a vertical flux
# of horizontal momentum that removes momentum from the layer immediately above: in other words,
# the flux is negative (downwards) when the velocity at the bottom boundary is positive, and
# positive (upwards) with the velocity at the bottom boundary is negative.
# This drag term is "quadratic" because the rate at which momentum is removed is proportional
# to ``\boldsymbol{u} |\boldsymbol{u}|``, where ``\boldsymbol{u} = u \boldsymbol{\hat{x}} + 
# v \boldsymbol{\hat{y}}`` is the horizontal velocity.
#
# The ``x``-component of the quadratic bottom drag is thus
#
# ```math
# \tau_{xz}(z=L_z) = - c^D u \sqrt{u^2 + v^2} \, ,
# ```
#
# while the ``y``-component is
#
# ```math
# \tau_{yz}(z=L_z) = - c^D v \sqrt{u^2 + v^2} \, ,
# ```
#
# where ``c^D`` is a dimensionless drag coefficient and ``\tau_{xz}(z=L_z)`` and ``\tau_{yz}(z=L_z)``
# denote the flux of ``u`` and ``v`` momentum at ``z = L_z``, the bottom of the domain.
#
# ### Vertical and horizontal viscosity and diffusivity
#
# Vertical and horizontal viscosities and diffusivities are required
# to stabilize the Eady problem and can be idealized as modeling the effect of
# turbulent mixing below the grid scale. For both tracers and velocities we use
# a Laplacian vertical diffusivity ``κ_z ∂_z^2 c`` and a horizontal
# hyperdiffusivity ``ϰ_h (∂_x^4 + ∂_y^4) c``.
#
# ### Eady problem summary and parameters
#
# To summarize, the Eady problem parameters along with the values we use in this example are
#
# | Parameter name | Description | Value | Units |
# |:--------------:|:-----------:|:-----:|:-----:|
# | ``f``          | Coriolis parameter | ``10^{-4}`` | ``\mathrm{s^{-1}}`` |
# | ``N``          | Buoyancy frequency (square root of ``\partial_z B``) | ``10^{-3}`` | ``\mathrm{s^{-1}}`` |
# | ``\alpha``     | Background vertical shear ``\partial_z U`` | ``10^{-3}`` | ``\mathrm{s^{-1}}`` |
# | ``c^D``        | Bottom quadratic drag coefficient | ``10^{-4}`` | none |
# | ``κ_z``        | Laplacian vertical diffusivity | ``10^{-2}`` | ``\mathrm{m^2 s^{-1}}`` |
# | ``ϰ_h``        | Biharmonic horizontal diffusivity | ``10^{-2} \times \Delta x^4 / \mathrm{day}`` | ``\mathrm{m^4 s^{-1}}`` |
#
# We start off by importing `Oceananigans`, `Printf`, and some convenient constants
# for specifying dimensional units:

using Printf
using Oceananigans
using Oceananigans.Units: hours, day, days
using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization
# ## The grid
#
# We use a three-dimensional grid with a depth of 4000 m and a
# horizontal extent of 1000 km, appropriate for mesoscale ocean dynamics
# with characteristic scales of 50-200 km.

Lx = 2
Nx = 128 # vertical resolution
Nz = 64  # vertical resolution
σ = 1.3  # stretching factor
Lz = 1.0 # depth (m)

# hyperbolically_spaced_faces(k) = Lz - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ))
# 
# grid = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),
#                                           topology = (Bounded, Flat, Bounded),
#                                           x=(-Lx/2, Lx/2),
#                                           z_faces = hyperbolically_spaced_faces)

grid = RegularRectilinearGrid(size=(Nx, Nz), x=(-Lx/2, Lx/2), z=(0, 1),
                              topology=(Periodic, Flat, Bounded))
                              
                              
# We plot vertical spacing versus depth to inspect the prescribed grid stretching:
# using Plots
# 
# plot(grid.Δzᵃᵃᶜ[1:Nz], grid.zᵃᵃᶜ[1:Nz],
#      marker = :circle,
#      ylabel = "Depth",
#      xlabel = "Vertical spacing",
#      legend = nothing)

# ## Boundary conditions
#
# The boundary conditions prescribe a quadratic drag at the bottom as a flux
# condition.

b★ = 1.0

@inline bₛ(x, y, t, p) = - p.b★ * cos(2π / p.Lx * x)

b_bcs = TracerBoundaryConditions(grid, top = ValueBoundaryCondition(bₛ, parameters = (b★=b★, Lx=grid.Lx)))

# ## Turbulence closures
#
# We use a horizontal hyperdiffusivity and a Laplacian vertical diffusivity
# to dissipate energy in the Eady problem.
# To use both of these closures at the same time, we set the keyword argument
# `closure` to a tuple of two closures.

Pr = 1.0   # The Prandtl number
Ra = 1e8   # The Rayleigh number

ν = sqrt(Pr * b★ * Lx^3 / Ra)  # [m² s⁻¹] Laplacian viscosity
κ = ν * Pr # [m² s⁻¹] Laplacian diffusivity

# ## Model instantiation
#
# We instantiate the model with the fifth-order WENO advection scheme, a 3rd order
# Runge-Kutta time-stepping scheme, and a `BuoyancyTracer`.

model = IncompressibleModel(
           architecture = CPU(),
                   grid = grid,
              advection = WENO5(),
            timestepper = :RungeKutta3,
                tracers = :b,
               buoyancy = BuoyancyTracer(),
                closure = IsotropicDiffusivity(ν=ν, κ=κ),#, time_discretization=VerticallyImplicitTimeDiscretization()),
    boundary_conditions = (b=b_bcs,)
)

# ## Simulation set-up
#
# We set up a simulation that runs for 10 days with a `JLD2OutputWriter` that saves the
# vertical vorticity and divergence every 2 hours.
#
# ### The `TimeStepWizard`
#
# The TimeStepWizard manages the time-step adaptively, keeping the
# Courant-Freidrichs-Lewy (CFL) number close to `1.0` while ensuring
# the time-step does not increase beyond the maximum allowable value
# for numerical stability given the specified background flow, Coriolis
# time scales, and diffusion time scales.

## Calculate absolute limit on time-step using diffusivities and
## background velocity.
max_Δt = 4e-2

wizard = TimeStepWizard(cfl=0.75, Δt=1e-3, max_change=1.2, max_Δt=max_Δt)

# ### A progress messenger
#
# We write a function that prints out a helpful progress message while the simulation runs.

CFL = AdvectiveCFL(wizard)

start_time = time_ns()

progress(sim) = @printf("i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n",
                        sim.model.clock.iteration,
                        prettytime(sim.model.clock.time),
                        prettytime(1e-9 * (time_ns() - start_time)),
                        prettytime(sim.Δt.Δt),
                        CFL(sim.model))
nothing # hide

# ### Build the simulation
#
# We're ready to build and run the simulation. We ask for a progress message and time-step update
# every 20 iterations,

simulation = Simulation(model, Δt = wizard, iteration_interval = 100,
                                                     stop_time = 60.05,
                                                      progress = progress)

# ### Output
#
# To visualize the baroclinic turbulence ensuing in the Eady problem,
# we use `ComputedField`s to diagnose and output vertical vorticity and divergence.
# Note that `ComputedField`s take "AbstractOperations" on `Field`s as input:

u, v, w = model.velocities # unpack velocity `Field`s

## y-component of vorticity [s⁻¹]
ζ = ComputedField(∂z(u) - ∂x(w))

## total flow speed [m s⁻¹]
speed = ComputedField(sqrt(u^2 + w^2))

outputs = (b = model.tracers.b, ζ = ζ, s = speed)

# With the vertical vorticity, `ζ`, and the horizontal divergence, `δ` in hand,
# we create a `JLD2OutputWriter` that saves `ζ` and `δ` and add them to
# `simulation`.

simulation.output_writers[:fields] = JLD2OutputWriter(model, outputs,
                                                      schedule = TimeInterval(0.1),
                                                        prefix = "horizontal_convection",
                                                         force = true)
nothing # hide

# All that's left is to press the big red button:

run!(simulation)

# ## Visualizing Eady turbulence
#
# We animate the results by opening the JLD2 file, extracting data for
# the iterations we ended up saving at, and ploting slices of the saved
# fields. We prepare for animating the flow by creating coordinate arrays,
# opening the file, building a vector of the iterations that we saved
# data at, and defining a function for computing colorbar limits:

using JLD2, Plots

## Coordinate arrays
xs, ys, zs = nodes(speed)
xb, yb, zb = nodes(model.tracers.b)
xζ, yζ, zζ = nodes(ζ)

## Open the file with our data
file = jldopen(simulation.output_writers[:fields].filepath)

## Extract a vector of iterations
iterations = parse.(Int, keys(file["timeseries/t"]))

# This utility is handy for calculating nice contour intervals:

function nice_divergent_levels(c, clim, nlevels=41)
    levels = range(-clim, stop=clim, length=nlevels)
    cmax = maximum(abs, c)
    clim < cmax && (levels = vcat([-cmax], levels, [cmax]))
    return levels
end
nothing # hide

# Now we're ready to animate.

@info "Making an animation from saved data..."

anim = @animate for (i, iter) in enumerate(iterations)

    ## Load 3D fields from file
    t = file["timeseries/t/$iter"]
    s_snapshot = file["timeseries/s/$iter"][:, 1, :]
    b_snapshot = file["timeseries/b/$iter"][:, 1, :]
    ζ_snapshot = file["timeseries/ζ/$iter"][:, 1, :]
    
    slim = 0.5
    slevels = vcat(range(0, stop=slim, length=31), [0.6])

    blim = 0.6
    blevels = vcat([-1], range(-blim, stop=blim, length=51), [1])
    
    ζlim = 9
    ζlevels = nice_divergent_levels(ζ_snapshot, ζlim)

    @info @sprintf("Drawing frame %d from iteration %d: max(ζ) = %.3f \n",
                   i, iter, maximum(abs, ζ_snapshot))

    xz_kwargs = (xlims = (-grid.Lx/2, grid.Lx/2), ylims = (0, grid.Lz),
                 xlabel = "x/h", ylabel = "z/h",
                 aspectratio = 2 * grid.Lz / grid.Lx,
                 linewidth = 0)

       speed = contourf(xs, zs, s_snapshot';
                        clims=(0, slim), levels=slevels,
                        color = :speed,
                        xz_kwargs...)

    buoyancy = contourf(xb, zb, b_snapshot';
                        clims=(-blim, blim), levels=blevels,
                        color = :thermal,
                        xz_kwargs...)

    vorticity = contourf(xζ, zζ, ζ_snapshot';
                         clims=(-ζlim, ζlim), levels=ζlevels,
                         color = :balance,
                         xz_kwargs...)

    plot(speed, buoyancy, vorticity,
            dpi = 120,
           size = (700.25, 1000.25),
           link = :x,
          layout = Plots.grid(3, 1),
          title = [@sprintf("√(u²+w²) @ t=%1.2f", t) @sprintf("buoyancy @ t=%1.2f", t) @sprintf("∂u/∂z - ∂w/∂x @ t=%1.2f", t)])

    iter == iterations[end] && close(file)
end

mp4(anim, "horizontal_convection.mp4", fps = 12) # hide
